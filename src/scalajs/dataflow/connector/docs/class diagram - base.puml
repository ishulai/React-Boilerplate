@startuml

interface ConnectionTester {
    +test(form: EntityForm): Unit
    {field}+nextHandler: ()=>_ <<override>>
    {field}+confirmHandler: ()=>_ <<override>>
}

ConnectorProxyEditor <|-- ConnectionTester
controls.AjaxClient <|-- ConnectionTester

class ConnectorDef <<case class>> {
    +categoryId: String
    +spec: Component
    +canEqual(that: Any): Boolean
    +equals(obj: Any): Boolean
}

interface ConnectorProxy {
    {abstract} connector: ConnectorDef
    {abstract} requiresSelector: Boolean
    +canImport: Boolean
    {field}+editCompleted: ()=>_
    +editor: Entity <<not implemented>>
    {abstract} name: String
    +edit(): Unit
    +toProtocol(): ConnectorProtocol
    {abstract} locationallyEquals(p: ConnectorProxy): Boolean
    +getObjectsToLoad: DataSource <<not implemented>>
}

ConnectorProxy *--> ConnectorDef
ConnectorProxy --> DataSource.DataSource

interface ConnectorProxyEditor {
    {abstract} proxy: ConnectorProxy
    +autoGenerateUI: Boolean
    +userDefinedUI: HTMLElement
    {abstract} fill(): Unit
    {abstract} collect(): Unit
}

controls.Entity <|-- ConnectorProxyEditor
controls.DomFunction <|-- ConnectorProxyEditor
ConnectorProxyEditor --> ConnectorProxy

namespace DatabaseConnector {
    class ServerInfo <<case class>> {
        +host: String
        +port: Int
        +databaseName: String
        +userName: String
        +password: String
        +isEmpty(): Boolean
        +equals(obj: Any): Boolean
        {static}+empty: ServerInfo
    }

    interface DatabaseConnector {
        {abstract} connectionUrl(): String
        {abstract} getConnection(): Connection
        {abstract}getPreviewTableSql(tableName: String)
        +testConnection(): String
        ~serializePreview(rs: ResultSet): String
        ~closeConnection(cn: Connection): Unit
        ~closeResultSet(cn: Connection, rs: ResultSet): Unit
    }

    core.BaseConnector <|-- DatabaseConnector
}

namespace DataSource {

    class DataSource <<case class>> {
        +proxy: ConnectorProxy
        +databases: ListBuffer[Database]
        +name(): String
        + +=(db: Database): ListBuffer[Database]
        +edit(node: TreeNode): Unit
        +clear(): Unit
    }

    class Database <<case class>> {
        +name: String
        +entities: ListBuffer[Entity]
        + +=(e: Entity): ListBuffer[Entity]
    }

    class Entity <<case class>> {
        +schema: String
        +name: String
        +qualifiedName: String
        +columns: Seq[Field]
    }

    DataSource o-> Database
    Database o-> Entity

}

package core <<dataflow_core>> {
    interface BaseConnector {
        +getCacheKey(catalog: String, table: String): String
        +init(context: String): BaseConnector
        +testConnection(): String
        +listDatabases(): Array[String]
        +listTables(databaseName: String): Array[DbEntity]
        +listColumns(datanaseName: String, schema: String, tableName: String): Array[Field]
        +previewTable(databaseName: String, tableName): String
        +load(spark: SparkSession, args: Any*): DataFrame
    }

    interface SparkLoader <<inner trait>> {
        +load(spark: SparkSession, databaseName: String, schema: String, tableName: String, columns: Schema): DataFrame <<not implemented>>
        +loadRemoteFile(spark: SparkSession, fileName: String): DataFrame
        +loadLocalFile(fileName: String): DataFrame
    }

    BaseConnector *--> SparkLoader
}

package controls {
    interface Entity {
        <<refer to controls\class diagram - entity>>
    }
    interface DomFunction{
        <<refer to controls\class diagram - base>>
    }

    interface AjaxClient {
        <<refer to controls\class diagram - base>>
    }
}

@enduml