@startuml

class Execution {
    process: Process
    runToActivity: Int
}

Execution --> Process

class Process {
    id: UUID
    activities: List[Activity]
    helper: ExecutionHelper
    topology(): ProcessTopology
    getScript(runTo: Int): String
}

Process "1"*--"many" Activity
Process --> ProcessTopology: generates
Process --> ExecutionHelper: uses

class ExecutionHelper {
    -activityMap: Map[Int, Activity]
    -portMap: Map[Int, ActivityPort]
    +connectionGetter: ConnectionInfo=>BaseConnector
    +getConnector(cinfo: ConnectionInfo): BaseConnector
    +findActivity(id: Int): Activity
    +findPort(id: Int): ActivityPort
}

class Activity {
    id: Int
    inPorts: List[ActivityPort]
    outPorts: List[ActivityPort]
    context: ActivityContext
    generation: Int
    helper: ExecutionHelper
    dfName: String
    populate(current: Int): Int
    getInboundActivity(): Activity
    getInboundActivity(index: Int): Activity
}

Activity *-- ActivityPort: inPorts, outPorts
Activity --> ActivityContext
Activity --> ExecutionHelper: uses

class Transition {
    fromPort: Int
    toPort: Int
}

Transition --> ActivityPort: fromPort, toPort \n (reference by id)

class ActivityPort {
    id: Int
    activityId: Int
    transitions: List[Transition]
}

ActivityPort "1"*--"many" Transition

class ActivityContext {
    isFactory: Boolean
    jar: JarSpec
    context: String
    getScript(id: Int): String
}

class ExecutionResult {
    activities: Map[Int, ActivityStatistic]
}

ExecutionResult "1"*--"many" ActivityStatistic

class ActivityStatistic {
    id: Int
    state: ActivityState
    duration: Long
    progress:Double
    resultSize: Long
    messages:String
    view: String
}

class ProcessTopology {
    generations: Int
    parallels: List[ParallelActivities]
}

ProcessTopology "1"*--"many" ParallelActivities

class ParallelActivities {
    generation: Int
    parallels: List[Activity]
}

ParallelActivities "1"*--"many" Activity

@enduml